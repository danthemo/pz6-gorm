# Практическое занятие №6

Ходыч Даниил Евгеньевчи

ЭФМО-02-25

# Запуск

Клонировать репозиторий -> заупстить main.go

```bash
git clone https://github.com/danthemo/pz6-gorm.git
cd pz6-gorm
go run ./...
```

# Что такое ORM?

ORM (Object-Relational Mapping) позволяет работать с базой данных через объекты и структуры программы, вместо написания SQL-запросов вручную, что ускоряет разработку, уменьшает количество шаблонного кода и снижает риск SQL-инъекций. 
GORM помогает быстро описать модели, автоматически создать таблицы через `AutoMigrate`, а также легко реализовать связи между сущностями (`1:N` и `M:N`).

# Скриншоты работы

1. Проверим работает ли сервер:
<img width="262" height="72" alt="1" src="https://github.com/user-attachments/assets/c892be5b-9957-4a20-80d2-5a78f2337440" />

2. Создание пользователя:
<img width="539" height="110" alt="2" src="https://github.com/user-attachments/assets/db29b56b-001b-4715-8c05-c8ed92e00fce" />

3. Создание заметки:
<img width="540" height="175" alt="3" src="https://github.com/user-attachments/assets/51813d01-1850-4aa6-9211-5f263bde4405" />

4. Получение заметки:
<img width="545" height="145" alt="4" src="https://github.com/user-attachments/assets/735d92ab-a682-481c-a978-7a48c4c4c13f" />

# Ответы на контрольные вопросы

### 1. Что такое ORM и зачем она нужна, если есть database/sql? Приведите 2–3 плюса и 1–2 минуса.
   
  Зачем нужна, если есть database/sql:

  Database/sql требует ручного написания SQL-запросов и маппинга результатов в структуры.
  ORM автоматизирует эту работу, позволяя сосредоточиться на бизнес-логике.
  
  Плюсы:
  
  - Ускорение разработки — меньше шаблонного кода, автоматический маппинг структур в таблицы
  
  - Безопасность — параметризованные запросы защищают от SQL-инъекций
  
  - Переносимость — один код работает с разными СУБД (PostgreSQL, MySQL, SQLite)
  
  Минусы:
  
  - Производительность — ORM может генерировать неоптимальные SQL-запросы
  
  - Ограниченность — сложные аналитические запросы проще писать на чистом SQL


### 2. Как в GORM описать связи `1:N` и `M:N`? Какие теги на полях вы использовали?

  Связь 1:N (один ко многим):
  
  ```go
  type User struct {
      ID    uint    `gorm:"primaryKey"`
      Name  string  `gorm:"size:100;not null"`
      Notes []Note  // 1:N - один пользователь много заметок
  }

  type Note struct {
      ID     uint   `gorm:"primaryKey"`
      Title  string `gorm:"size:200;not null"`
      UserID uint   `gorm:"not null"` // внешний ключ
      User   User
  }
  ```

  Связь M:N (многие ко многим):

  ```
  go
  type Note struct {
      ID    uint   `gorm:"primaryKey"`
      Title string `gorm:"size:200;not null"`
      Tags  []Tag  `gorm:"many2many:note_tags;"` // M:N через таблицу note_tags
  }
  
  type Tag struct {
      ID    uint   `gorm:"primaryKey"`
      Name  string `gorm:"size:50;uniqueIndex;not null"`
      Notes []Note `gorm:"many2many:note_tags;"`
  }
  ```

  Использованные теги:
  
  - `gorm:"primaryKey"` — первичный ключ
  
  - `gorm:"size:N"` — ограничение размера строки
  
  - `gorm:"not null"` — NOT NULL ограничение
  
  - `gorm:"uniqueIndex"` — уникальный индекс
  
  - `gorm:"many2many:table_name"` — связь многие-ко-многим

### 3. Что делает `AutoMigrate`? В каких случаях его недостаточно?

  AutoMigrate автоматически создаёт или обновляет таблицы в БД на основе структур Go:
  
  - Создаёт новые таблицы, если их нет
  
  - Добавляет новые колонки при изменении структур
  
  Когда его недостаточно:
  
  - Удаление колонок — AutoMigrate не удаляет колонки, удалённые из структуры
  
  - Изменение типов — не изменяет типы существующих колонок
  
  - Переименование таблиц/колонок, добавление сложных индексов
  
  - Контроль версий схемы — нет истории миграций, отката изменений

### 4. Чем `Preload` отличается от обычного `Find/First`? Когда его применять?

  `Find/First` загружают только данные основной модели:

  ```go
  var note Note
  db.First(&note, 1) // Загружает только поля из таблицы notes
  ```

  Preload дополнительно загружает связанные данные:

  ```go
  var note Note
  db.Preload("User").Preload("Tags").First(&note, 1)
  // Загружает заметку + связанного пользователя + теги
  ```

  Когда применять `Preload`:
  
  - Когда нужны данные связанных сущностей для отображения
  
  - Для избежания N+1 проблемы (когда каждая связь требует отдельного запроса)
  
  - В REST API при возврате полных данных с связями
  
  Без Preload связанные поля будут пустыми или содержать только ID.
